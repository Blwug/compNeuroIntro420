** Springs as DE Practice
   :PROPERTIES:
   :CUSTOM_ID: springs-as-de-practice
   :END:

*** Why
    :PROPERTIES:
    :CUSTOM_ID: why
    :END:

1. It is good to start with simple situations.
2. It is good to start with scenarios where you can trust your
   intuitions.
3. It is good if you can start with examples where you can "look up" the
   right answer, before implementing models for which you do not have
   the right answer.

*** The Main Equation for the Frictionless Spring
    :PROPERTIES:
    :CUSTOM_ID: the-main-equation-for-the-frictionless-spring
    :END:
$ \begin{equation} \frac{d^2s}{dt^2} = -Ps(t) \end{equation} $

What does $s(t)$ mean?

What is a mathematical function?

What is the first derivative of distance as a function of time?

What is the second derivative of distance as a function of time?

Write them down.

*** Golden Rule of Iteration
    :PROPERTIES:
    :CUSTOM_ID: golden-rule-of-iteration
    :END:
Your new value is your old value + the amount it changed.

How much did it change? Figure it out using the rate of change.

What is the rate of change (in words)?

To figure out how much something changed you need something more than
just the rate of change. In words, what?

Remember to keep it simple. What value can we set $P$, the spring
constant, to that will keep things simple. The answer is not 0. Why?

#+BEGIN_SRC python
  #Constants gathered at top. Makes updating easy
  P = 0.5
  tstep = 0.1
  s0 = 10;#initial condition
  s=[s0]
  v=[0];#why can I assume this is zero?
  a=[]

  #local functions we need
  def accel(s_of_t):
      return((-1)*P*(s_of_t))

  #this is called a "closure"; don't have to use - just sharing
  def update_by_deltaT (deltaT):
      def newfromold(oldval,rate_of_change):
          return(oldval + rate_of_change * deltaT)
      return(newfromold)

  newv = update_by_deltaT(tstep)
      
  for i in range(1000):
      a.append(accel(s[-1]))
      v.append(newv(v[-1],a[-1]))
      s.append(newv(s[-1],v[-1]))
#+END_SRC

#+BEGIN_SRC python
  %matplotlib inline

  import matplotlib
  import numpy as np
  import matplotlib.pyplot as plt

  plt.plot(s)
  plt.show()
#+END_SRC

[[file:799485670a8727889b07376b60dfa44245ba431c.png]]

*** Thought Questions/Class Questions
    :PROPERTIES:
    :CUSTOM_ID: thought-questionsclass-questions
    :END:

1. Show how the update method I use is related to the definition of a
   derivative.
2. What is this updating method called? In general, what are the
   drawbacks of using it?
3. What are the alternatives?
4. What happens if P is a negative number? Why does that make sense.
5. I said that things that are proportional to themselves usually have
   an "exponential" in the solution. Why then do we see a sine wave? Is
   there a connection between exponentials and sine waves? Hint: See
   your answer to number 2 above.

#+BEGIN_SRC python
#+END_SRC

** The Damped Oscillator - example image for homework
   :PROPERTIES:
   :CUSTOM_ID: the-damped-oscillator---example-image-for-homework
   :END:
$-P \times s(t) - k \times v(t)$

#+BEGIN_SRC python
  %matplotlib inline

  import matplotlib
  import numpy as np
  import matplotlib.pyplot as plt

  plt.plot(s)
  plt.show()
#+END_SRC

[[file:8bbb15d6204abb2fd45f78f57c1b8e08f596a674.png]]

#+BEGIN_SRC python
#+END_SRC
